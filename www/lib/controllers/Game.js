// Generated by CoffeeScript 1.6.1
(function() {
  var Game, Orb, attractionRange, defaults, detractionRange, device, geo,
    _this = this;

  geo = require('../helpers/geometry');

  device = require('../core/device');

  Orb = require('./Orb').Orb;

  detractionRange = 30;

  attractionRange = 60;

  defaults = {
    orbsCount: 6
  };

  Game = (function() {

    function Game(options) {
      var _this = this;
      this.getInitialVector = function(index) {
        return Game.prototype.getInitialVector.apply(_this, arguments);
      };
      this.getRelativeVector = function(orb, target) {
        return Game.prototype.getRelativeVector.apply(_this, arguments);
      };
      this.applyForces = function() {
        return Game.prototype.applyForces.apply(_this, arguments);
      };
      this.resetPositions = function() {
        return Game.prototype.resetPositions.apply(_this, arguments);
      };
      this.generateOrbs = function() {
        return Game.prototype.generateOrbs.apply(_this, arguments);
      };
      options = $.extend(true, {}, defaults, options);
      this.display = options.display;
      this.orbsCount = options.orbsCount;
      this.orbs = [];
      this.generateOrbs();
      this.applyForces();
      this.bind();
    }

    Game.prototype.bind = function() {
      var self;
      self = this;
      return this.display.on(device.get('clickEvent'), '[data-role="orb"]', function() {
        $(this).data('orb').switchState();
        return self.applyForces();
      });
    };

    Game.prototype.generateOrbs = function() {
      var i, orb, _i, _ref, _results;
      _results = [];
      for (i = _i = 0, _ref = this.orbsCount - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        orb = new Orb(0, 0);
        this.orbs.push(orb);
        _results.push(this.display.append(orb.element));
      }
      return _results;
    };

    Game.prototype.resetPositions = function() {
      var i, orb, _i, _len, _ref, _results;
      _ref = this.orbs;
      _results = [];
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        orb = _ref[i];
        orb.x = 0;
        orb.y = 0;
        orb.applyVector(this.getInitialVector(i));
        _results.push(orb.update(true));
      }
      return _results;
    };

    Game.prototype.applyForces = function() {
      var i, orb, relativeVector, summedVectors, target, vectors, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _results;
      summedVectors = [];
      this.resetPositions();
      _ref = this.orbs;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        orb = _ref[_i];
        vectors = [];
        _ref1 = this.orbs;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          target = _ref1[_j];
          if (target !== orb) {
            relativeVector = this.getRelativeVector(orb, target);
            if (relativeVector != null) {
              vectors.push(relativeVector);
            }
          }
        }
        summedVectors.push(geo.sumVectors(vectors));
      }
      _ref2 = this.orbs;
      _results = [];
      for (i = _k = 0, _len2 = _ref2.length; _k < _len2; i = ++_k) {
        orb = _ref2[i];
        orb.applyVector(summedVectors[i]);
        _results.push(orb.update());
      }
      return _results;
    };

    Game.prototype.getRelativeVector = function(orb, target) {
      var angleDeg, angleRad, dist, force;
      dist = geo.getDistance(target, orb);
      force = null;
      if (target.getState() === 'attractor' && dist < attractionRange) {
        force = (dist - attractionRange) / 2;
        angleRad = Math.atan2(orb.y - target.y, orb.x - target.x);
      } else if (target.getState() === 'detractor' && dist < detractionRange) {
        force = (dist - detractionRange) / 2;
        angleRad = Math.atan2(target.y - orb.y, target.x - orb.x);
      }
      if (force != null) {
        angleDeg = geo.radToDeg(angleRad);
        return geo.degToVector(angleDeg, force);
      }
      return null;
    };

    Game.prototype.getInitialVector = function(index) {
      var deg, vector;
      deg = (360 / this.orbsCount) * index;
      vector = geo.degToVector(deg, 5);
      return vector;
    };

    return Game;

  })();

  module.exports = {
    Game: Game
  };

}).call(this);
