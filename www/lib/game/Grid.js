// Generated by CoffeeScript 1.6.1
(function() {
  var Grid, classNames, debug, defaults, delayAfterUpdate, fx, getByRole, gridPadding, renderer, showTileDelay, showTileDuration, tileSpacing,
    _this = this;

  getByRole = require('../helpers/dom').getByRole;

  renderer = require('../core/renderer');

  debug = require('../core/debug');

  fx = require('../ui/fx');

  tileSpacing = 10;

  gridPadding = 20;

  showTileDelay = 200;

  showTileDuration = 400;

  delayAfterUpdate = debug.get('fast') ? 0 : 1200;

  defaults = {
    masked: false,
    size: [3, 3],
    onTilesShown: null,
    targetsNum: 4
  };

  classNames = {
    showTile: 'show',
    ready: 'ready'
  };

  Grid = (function() {

    function Grid(options) {
      var x, y, _i, _j, _ref, _ref1,
        _this = this;
      this.updateTile = function(x, y, options, callback) {
        return Grid.prototype.updateTile.apply(_this, arguments);
      };
      this.setTile = function(x, y, options) {
        return Grid.prototype.setTile.apply(_this, arguments);
      };
      this.getRandomTile = function(conditions) {
        if (conditions == null) {
          conditions = null;
        }
        return Grid.prototype.getRandomTile.apply(_this, arguments);
      };
      this.getTile = function(x, y) {
        return Grid.prototype.getTile.apply(_this, arguments);
      };
      this.resize = function() {
        return Grid.prototype.resize.apply(_this, arguments);
      };
      this.getTileWidth = function() {
        return Grid.prototype.getTileWidth.apply(_this, arguments);
      };
      this.showNextTile = function() {
        return Grid.prototype.showNextTile.apply(_this, arguments);
      };
      this.showTiles = function(animate) {
        return Grid.prototype.showTiles.apply(_this, arguments);
      };
      this.render = function(wrapper, animate) {
        if (animate == null) {
          animate = false;
        }
        return Grid.prototype.render.apply(_this, arguments);
      };
      this.renderTile = function(tile, options) {
        if (options == null) {
          options = {};
        }
        return Grid.prototype.renderTile.apply(_this, arguments);
      };
      this.generateTargets = function() {
        return Grid.prototype.generateTargets.apply(_this, arguments);
      };
      this.positions = [];
      options = $.extend(true, {}, defaults, options);
      this.size = options.size;
      this.player = options.opponent ? 'opponent' : 'self';
      this.masked = options.opponent ? true : false;
      this.onTilesShown = options.onTilesShown;
      this.targetsNum = options.targetsNum;
      for (y = _i = 0, _ref = this.size[1] - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; y = 0 <= _ref ? ++_i : --_i) {
        this.positions[y] = [];
        for (x = _j = 0, _ref1 = this.size[0] - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
          this.positions[y][x] = {
            value: null,
            x: x,
            y: y,
            hit: false
          };
        }
      }
      this.generateTargets();
    }

    Grid.prototype.generateTargets = function() {
      var x, y, _results;
      this.targets = [];
      _results = [];
      while (this.targets.length < this.targetsNum) {
        x = Math.floor(Math.random() * this.size[0]);
        y = Math.floor(Math.random() * this.size[1]);
        if (this.positions[y][x].value == null) {
          this.positions[y][x].value = 'target';
          _results.push(this.targets.push({
            x: x,
            y: y
          }));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Grid.prototype.renderTile = function(tile, options) {
      var element, tileContext;
      if (options == null) {
        options = {};
      }
      tileContext = $.extend(true, {}, tile, options);
      if (this.masked && !tileContext.revealed) {
        tileContext.masked = true;
      }
      if (tileContext.value == null) {
        tileContext.empty = true;
      }
      element = $(renderer.render('partials/game/tile', tileContext));
      return element.data('tile', tile);
    };

    Grid.prototype.render = function(wrapper, animate) {
      var row, tile, _i, _j, _len, _len1, _ref,
        _this = this;
      if (animate == null) {
        animate = false;
      }
      this.wrapper = wrapper;
      this.element = $(renderer.render('partials/game/grid'));
      _ref = this.positions;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        row = _ref[_i];
        for (_j = 0, _len1 = row.length; _j < _len1; _j++) {
          tile = row[_j];
          tile.element = this.renderTile(tile, {
            animate: animate
          });
          this.element.append(tile.element);
        }
      }
      this.element.appendTo(wrapper);
      this.tileElements = getByRole('game-tile', this.element);
      this.resize();
      $(window).on('resize', function() {
        return _this.resize();
      });
      if (animate && !debug.get('fast')) {
        return setTimeout(function() {
          wrapper.addClass(classNames.ready);
          return _this.showTiles();
        }, 1);
      } else {
        this.tileElements.addClass(classNames.showTile);
        this.shownTiles = this.size[0] * this.size[1];
        return setTimeout(function() {
          _this.element.addClass(classNames.ready);
          if (_this.onTilesShown != null) {
            return _this.onTilesShown();
          }
        }, 1);
      }
    };

    Grid.prototype.showTiles = function(animate) {
      var i, _i, _ref, _results,
        _this = this;
      this.shownTiles = 0;
      _results = [];
      for (i = _i = 0, _ref = this.size[0] * this.size[1]; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        _results.push(setTimeout(function() {
          return _this.showNextTile();
        }, i * showTileDelay));
      }
      return _results;
    };

    Grid.prototype.showNextTile = function() {
      var _this = this;
      $(this.tileElements[this.shownTiles]).addClass(classNames.showTile);
      this.shownTiles++;
      if (this.shownTiles === this.size[0] * this.size[1] && (this.onTilesShown != null)) {
        return setTimeout(function() {
          return _this.onTilesShown();
        }, showTileDuration);
      }
    };

    Grid.prototype.getTileWidth = function() {
      return Math.floor((this.wrapper.innerWidth() - gridPadding * 2) / this.size[0] - tileSpacing - tileSpacing / this.size[0]);
    };

    Grid.prototype.resize = function() {
      var tileWidth;
      tileWidth = this.getTileWidth();
      this.tileElements.css({
        width: tileWidth,
        height: tileWidth
      });
      return this.element.css({
        marginTop: -(tileWidth * this.size[1] + tileSpacing * this.size[1]) / 2
      });
    };

    Grid.prototype.getTile = function(x, y) {
      return this.positions[y][x];
    };

    Grid.prototype.getRandomTile = function(conditions) {
      var key, row, tile, tiles, value, _i, _j, _len, _len1, _ref;
      if (conditions == null) {
        conditions = null;
      }
      tiles = [];
      _ref = this.positions;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        row = _ref[_i];
        for (_j = 0, _len1 = row.length; _j < _len1; _j++) {
          tile = row[_j];
          if (conditions != null) {
            for (key in conditions) {
              value = conditions[key];
              if (tile[key] === value) {
                tiles.push(tile);
              }
            }
          } else {
            tiles.push(tile);
          }
        }
      }
      if (tiles.length) {
        return tiles[Math.floor(Math.random() * tiles.length)];
      }
      return null;
    };

    Grid.prototype.setTile = function(x, y, options) {
      return this.positions[y][x] = $.extend(this.getTile(x, y), options);
    };

    Grid.prototype.updateTile = function(x, y, options, callback) {
      var newElement, tile, tileWidth,
        _this = this;
      tileWidth = this.getTileWidth();
      this.setTile(x, y, options);
      tile = this.getTile(x, y);
      newElement = this.renderTile(tile);
      newElement.css({
        width: tileWidth,
        height: tileWidth
      });
      return fx.revealTile(tile.element, newElement, this.player, function() {
        if (typeof callback === 'function') {
          return setTimeout(function() {
            return callback();
          }, delayAfterUpdate);
        }
      });
    };

    return Grid;

  })();

  module.exports = {
    Grid: Grid
  };

}).call(this);
